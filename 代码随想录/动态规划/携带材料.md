# [携带研究材料](携带研究材料"[题目地址](https://kamacoder.com/problempage.php?pid=1052)")

## 题目描述
小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的重量，并且具有不同的价值。

小明的行李箱所能承担的总重量是有限的，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料可以选择无数次，并且可以重复选择。

### 思路1：完全背包（二维dp）🌟

```java
import java.util.Scanner;

public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt(); // 研究材料的种类
        int V = sc.nextInt(); // 行李所能承担的总重量 
        int[] w = new int[N];
        int[] v = new int[N];
        for(int i = 0; i < N; i++){
            w[i] = sc.nextInt(); // 第 i 种研究材料的重量
            v[i] = sc.nextInt(); // 第 i 种研究材料的价值
        }

        // 动态规划 完全背包问题——每个材料可以重复选择无数次
        int[][] dp = new int[N][V + 1]; // dp[i][j] 表示在容量为j时，从0-i种类中选择装 的 最大价值

        // 初始化
        for (int j = w[0]; j <= V; j++) {
            dp[0][j] = dp[0][j - w[0]] + v[0];
        }

        for(int i = 1; i < N; i++){
            for(int j = 0; j <= V; j++){
                if(j >= w[i]){
                    // 选择不装 种类i的最大价值 / 选择装 种类i的最大价值
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - w[i]] + v[i]);
                }else{
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        System.out.println(dp[N - 1][V]);

        sc.close();
    }
}
```

#### 复杂度分析
时间复杂度：O(N * V)

空间复杂度：O(N * V)

----

### 思路2：完全背包（一维dp）🌟

对于第 i 种物品，如果当前容量 j 能放下它（`j >= w[i]`）：
- 不拿它：保持当前最优 dp[j]
- 拿它一次：从“减去该物品重量后的容量”转移过来，再加上该物品价值


```java
import java.util.Scanner;

public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt(); // 研究材料的种类
        int V = sc.nextInt(); // 行李所能承担的总重量 
        int[] w = new int[N];
        int[] v = new int[N];
        for(int i = 0; i < N; i++){
            w[i] = sc.nextInt(); // 第 i 种研究材料的重量
            v[i] = sc.nextInt(); // 第 i 种研究材料的价值
        }

        // 动态规划 完全背包问题——每个材料可以重复选择无数次
        int[] dp = new int[V + 1];
        for(int i = 0; i < N; i++){
            for(int j = 0; j <= V; j++){
                if(j >= w[i]){
                    // 选第 i 种：dp[j - w[i]] + v[i] （同一行，可以重复使用——正序）
                    dp[j] = Math.max(dp[j], dp[j - w[i]] + v[i]);
                }else{
                    dp[j] = dp[j]; // 不选第 i 种：dp[j]
                }
            }
        }
        System.out.println(dp[V]);
        sc.close();
    }
}
```

#### 复杂度分析
时间复杂度：O(N * V)

空间复杂度：O(V)

### 总结
