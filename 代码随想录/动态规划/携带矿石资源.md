# [携带矿石资源](携带矿石资源"[题目地址](https://kamacoder.com/problempage.php?pid=1066)")

## 题目描述
你是一名宇航员，即将前往一个遥远的行星。在这个行星上，有许多不同类型的矿石资源，每种矿石都有不同的重要性和价值。你需要选择哪些矿石带回地球，但你的宇航舱有一定的容量限制。 

给定一个宇航舱，最大容量为 C。现在有 N 种不同类型的矿石，每种矿石有一个重量 w[i]，一个价值 v[i]，以及最多 k[i] 个可用。不同类型的矿石在地球上的市场价值不同。你需要计算如何在不超过宇航舱容量的情况下，最大化你所能获取的总价值。

### 思路：多重背包🌟

- 物品种类是有限的，因此可以转为01背包问题

```java
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int C = sc.nextInt(); // 宇航舱的容量
        int N = sc.nextInt(); // 矿石的种类数量
        int[] w = new int[N]; // N 种矿石的重量
        int[] v = new int[N]; // N 种矿石的价格
        int[] k = new int[N]; // N 种矿石的可用数量上限

        for(int i = 0; i < N; i++){
            w[i] = sc.nextInt();
        }
        for(int i = 0; i < N; i++){
            v[i] = sc.nextInt();
        }
        for(int i = 0; i < N; i++){
            k[i] = sc.nextInt();
        }

        // 因为每个矿石只有k个 所以可以展开——有限的——转为01背包问题
        List<Integer> weightSum = new ArrayList<>();
        List<Integer> valueSum = new ArrayList<>();

        for(int i = 0; i < N; i++){
            for(int j = 0; j < k[i]; j++){
                weightSum.add(w[i]);
                valueSum.add(v[i]);
            }
        }

        // 转为数组
        int len = weightSum.size();
        int[] weight = new int[len];
        int[] value = new int[len];
        for(int i = 0; i < len; i++){
            weight[i] = weightSum.get(i);
            value[i] = valueSum.get(i);
        }

        int[] dp = new int[C + 1]; // dp[i]表示 背包容量大小
        // 01背包问题 —— 先物品 再背包
        for(int i = 0; i < len; i++){
            for(int j = C; j >= weight[i]; j--){
                // 不选择物品i 和 选择 物品i
                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
            }
        }

        System.out.println(dp[C]);

        sc.close();
    }
}
```

#### 复杂度分析
时间复杂度：O(C * len)

空间复杂度：O(C)

### 总结
