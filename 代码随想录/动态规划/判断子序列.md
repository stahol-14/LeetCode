# [判断子序列](判断子序列"[题目地址](https://leetcode.cn/problems/is-subsequence/description/)")

## 题目描述
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

进阶：

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

### 思路1：双指针


```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        if(s.length() > t.length()) return false;
        // 双指针判断
        int i = 0, j = 0;
        while(i < s.length() && j < t.length()){
            if(s.charAt(i) == t.charAt(j)){
                i++;
            }
            j++; // 无论是否相同 j都要后移 继续扫描字符串t
        }

        return i == s.length();
    }
}
```

#### 复杂度分析
时间复杂度：O(n)

空间复杂度：O(1)

----

### 思路2：动态规划🌟

- 作为编辑距离的入门题

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int m = s.length(), n = t.length();
        if(m > n) return false;

        // dp[i][j] = s 前 i 个字符 和 t 前 j 个字符的最长公共子序列长度
        int[][] dp = new int[m + 1][n + 1];
        
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(s.charAt(i - 1) == t.charAt(j - 1)){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }else{
                    dp[i][j] = dp[i][j - 1]; // 删除字符串t当前指向的字符
                }
            }
        }

        return dp[m][n] == m;
    }
}
```

#### 复杂度分析
时间复杂度：O(m * n)

空间复杂度：O(m * n)

### 总结
