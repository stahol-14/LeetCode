# [最长递增子序列](最长递增子序列"题目地址")

## 题目描述
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

### 思路1：动态规划🌟

- 外层 i 遍历整个数组，计算以 nums[i] 结尾的 LIS 长度。
- 内层 j 遍历 0 ~ i-1，寻找 在 nums[i] 之前比它小的元素。
  - 如果 nums[j] < nums[i]，说明 nums[i] 可以接在 nums[j] 的递增子序列后面

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        if(n <= 1) return n;

        int[] dp = new int[n]; // 以 nums[i] 结尾的最长递增子序列长度
        for(int i = 0; i < n; i++){
            dp[i] = 1; // 对dp进行初始化——每个元素至少能作为一个长度为1的序列
        }

        int res = 1;
        // 外层 i 遍历整个数组，计算以 nums[i] 结尾的长度
        for(int i = 1; i < n; i++){ 
            // 内层 j 遍历 0 ~ i-1，寻找 在 nums[i] 之前比它小的元素
            for(int j = 0; j < i; j++){
                if(nums[j] < nums[i]){
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }

            res = Math.max(dp[i], res);
        }
        
        return res;
    }
}
```

#### 复杂度分析
时间复杂度：O(n ^ 2)

空间复杂度：O(n)

----

### 思路2：二分查找+贪心🌟

贪心：

- 维护一个数组 array，它的长度表示目前找到的 最长递增子序列的长度
  - 遍历数组 nums：
  - 如果 nums[i] 比 array 的最后一个元素大，说明可以延长递增序列，直接 push_back
  - 否则，用 二分查找 找到 array 中第一个大于等于 nums[i] 的位置，用 nums[i] 替换

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        // 使用 二分查找 + 贪心 进行优化——降低时间复杂度
        List<Integer> array = new ArrayList<>(); // 记录递增子序列
        
        for(int num : nums){
            // 子序列为空 或 序列末尾整数 小于 当前数
            if(array.isEmpty() || array.get(array.size() - 1) < num){
                array.add(num); // 加入
            }else{
                // 找合适的位置 进行替换——替换到第一个大于等于该数的元素
                int left = 0;
                int right = array.size() - 1;
                // 进行二分查找 —— 闭区间
                while(left < right){
                    int mid = left + ((right - left) >> 1);

                    if(array.get(mid) < num){
                        left = mid + 1;
                    }else{
                        right = mid;
                    }
                }
                // 找到第一个 >= num的位置
                array.set(left, num);
            }
        }

        return array.size(); // 返回递增子序列的长度
    }
}
```

#### 复杂度分析
时间复杂度：O(n log n)，每个元素用二分查找 O(log n) 处理，n 个元素总共 O(n log n)。

空间复杂度：O(n)，辅助数组的大小

### 总结
- 子序列：可以删除元素，不连续
- 子数组：不可以删除元素，连续
- 子串：不可以删除元素，连续