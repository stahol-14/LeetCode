# [不同的子序列](不同的子序列"[题目地址](https://leetcode.cn/problems/distinct-subsequences/description/)")

## 题目描述
给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数。

测试用例保证结果在 32 位有符号整数范围内

### 思路：动态规划🌟

- 定义：
  - dp[i][j] 表示 s 的前 i 个字符中，t 的前 j 个字符出现的子序列个数。

- 初始化：
  - dp[i][0] = 1 （t 是空串时，任何 s 的子序列都能匹配到一个空串）。
  - dp[0][j] = 0 （s 是空串时，无法匹配非空的 t）。

- 状态转移：
  - 如果 s[i-1] == t[j-1]，那么可以有两种选择：
    - 用 s[i-1] 来匹配 t[j-1]：数量是 dp[i-1][j-1]
    - 不用 s[i-1]：数量是 dp[i-1][j]
  - 所以：
    - `dp[i][j] = dp[i-1][j-1] + dp[i-1][j]`
  - 如果 s[i-1] != t[j-1]，那么只能不使用 s[i-1]：
    - dp[i][j] = dp[i-1][j]


```java
class Solution {
    public int numDistinct(String s, String t) {
        int m = s.length(), n = t.length();

        // dp[i][j]表示 s 的前 i 个字符中，t 的前 j 个字符出现的子序列个数
        int[][] dp = new int[m + 1][n + 1]; 

        // 对dp数组进行初始化
        for(int i = 0; i <= m; i++){
            dp[i][0] = 1; // 对于字符串t为空串 s的子串为1
        }
        // for(int j = 0; j <= n; j++){
        //     dp[0][j] = 0; // 对于s为空串 只能为0，新建的数组 默认为0 
        // }

        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(s.charAt(i - 1) == t.charAt(j - 1)){
                    // 相同字符 判断是否使用：使用当前字符 或 不使用 s[i-1]
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                }else{
                    // 字符不同，只能跳过 s[i-1]
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        return dp[m][n];
    }
}
```

#### 复杂度分析
时间复杂度：O(n * m)

空间复杂度：O(n * m)

### 总结
