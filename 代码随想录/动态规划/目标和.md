# [目标和](目标和"[题目地址](https://leetcode.cn/problems/target-sum/description/)")

## 题目描述
给你一个非负整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

- 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。

返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

### 思路：回溯（效果不好❌）

```java
class Solution {
    int res = 0;
    public int findTargetSumWays(int[] nums, int target) {
        dfs(nums, 0, 0, target);
        return res;
    }

    private void dfs(int[] nums, int i, int sum, int target){
        if(i == nums.length){
            if(sum == target) res++;
            return ;
        }
        dfs(nums, i + 1, sum + nums[i], target);
        dfs(nums, i + 1, sum - nums[i], target);
    }
}
```

#### 复杂度分析
时间复杂度：最坏 O(2^n)

空间复杂度：

----

### 思路2：动态规划🌟

- 假设正数和为P，负数和的绝对值为N，则：
  - P + N = sum
  - P - N = target
  - P = (sum + target) / 2

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        // 对每个元素增加符号，使得和为target
        // 所有正整数和（原始） 修改符号后（正数和P）（负数和N）
        int sum = 0;
        for(int num : nums){
            sum += num;
        }

        // P + N = sum;  P - N = target; ==> P = (sum + target) / 2

        if(sum < Math.abs(target)) return 0; // 超出区间
        if((sum + target) % 2 == 1) return 0; // 奇数无法凑出P

        int P = (sum + target) / 2;
        int[] dp = new int[P + 1]; // dp[i] 代表 和为i的方法种类
        dp[0] = 1; // 初始化 和为0 只有一种方法 什么都不选

        for(int i = 0; i < nums.length; i++){
            for(int j = P; j >= nums[i]; j--){
                // dp[j] = dp[j] + dp[j - nums[i]]; 选 + 不选
                dp[j] += dp[j - nums[i]];
            }
        }

        return dp[P];
    }
}
```

#### 复杂度分析
时间复杂度：O(M * N)

空间复杂度：O(N)

### 总结
