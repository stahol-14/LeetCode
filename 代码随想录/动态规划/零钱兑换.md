# [零钱兑换](零钱兑换"[题目地址](https://leetcode.cn/problems/coin-change/description/)")

## 题目描述
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

### 思路：完全背包🌟

> 注：这里不能使用贪心
> 为什么单纯贪心不可靠？
> 反例一：coins = [1, 3, 4], amount = 6
> 贪心：先拿 4 → 剩 2 → 只能 1+1 → 共 3 枚
> 最优：3 + 3 → 2 枚 ✅
> 反例二：coins = [1, 11, 5], amount = 15
> 贪心：先拿 11 → 还要 1×4 → 5 枚
> 最优：5 + 5 + 5 → 3 枚 ✅
> “先用大面额”并不一定最优【主要是因为硬币的价值不一定都是统一的值，如 1，5，10】

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        
        int[] dp = new int[amount + 1]; // dp[j] 凑足总额为j所需钱币的最少个数为dp[j]
        int max = Integer.MAX_VALUE;

        for(int i = 0; i <= amount; i++){
            dp[i] = max; //初始化dp数组为最大值
        }
        dp[0] = 0; // 当金额为0时需要的硬币数目为0

        for(int i = 0; i < coins.length; i++){
            for(int j = 1; j <= amount; j++){
                // 可以多次使用——完全背包——先物品 再背包
                if(j >= coins[i] && dp[j - coins[i]] != max){
                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
                }
            }
        }

        return dp[amount] == max ? -1 : dp[amount];
    }
}
```

#### 复杂度分析
时间复杂度：O(amount * n)

空间复杂度：O(amount)

### 总结
