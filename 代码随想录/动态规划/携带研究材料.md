# [携带研究材料](携带研究材料"[题目地址](https://kamacoder.com/problempage.php?pid=1046)")

## 题目描述
小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 

小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。

### 思路：动态规划（二维-先物品再背包）🌟


```java
import java.util.Scanner;


public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int M = sc.nextInt(); // 研究材料的种类
        int N = sc.nextInt(); // 小明的行李空间

        int[] w = new int[M];
        int[] v = new int[M];
        for(int i = 0; i < M; i++){
            w[i] = sc.nextInt();
        }
        for(int i = 0; i < M; i++){
            v[i] = sc.nextInt();
        }

        // 数据输入完成 开始初始化
        int[][] dp = new int[M + 1][N + 1];

        // 开始dp 找最大
        for(int i = 1; i <= M; i++){
            int wi = w[i - 1], vi = v[i - 1];
            for(int j = 0; j <= N; j++){
                if(wi > j){
                    dp[i][j] = dp[i - 1][j]; // 无法装当前物品
                }else{
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - wi] + vi);
                }
            }
        }

        System.out.println(dp[M][N]);

        sc.close();
    }
}
```

#### 复杂度分析
时间复杂度：O(M * N)

空间复杂度：O(M + N)

---- 

### 思路2：动态规划（一维数组）🌟
注：在遍历背包时，要**倒序遍历**
- 为了保证物品i只被放入一次
- 并且只能选择：**先物品，再背包**

```java
import java.util.Scanner;

public class Main{
    public static void main(String[] arga){
        Scanner sc = new Scanner(System.in);
        int M = sc.nextInt();
        int N = sc.nextInt();

        int[] w = new int[M];
        int[] v = new int[M];
        for(int i = 0; i < M; i++){
            w[i] = sc.nextInt();
        }
        for(int i = 0; i < M; i++){
            v[i] = sc.nextInt();
        }

        int[] dp = new int[N + 1]; // dp[j]：容量为 j 的最大价值

        for(int i = 0; i < M; i++){
            // 0/1 背包必须从大到小遍历容量，避免同一物品被重复使用
            for(int j = N; j >= w[i]; j--){
                dp[j] = Math.max(dp[j], dp[j - w[i]] + v[i]);
            }
        }

        System.out.println(dp[N]);

        sc.close();
    }
}
```

#### 复杂度分析
时间复杂度：O(M * N)

空间复杂度：O(N)

### 总结
