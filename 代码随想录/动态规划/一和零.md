# [一和零](一和零"[题目地址](https://leetcode.cn/problems/ones-and-zeroes/description/)")

## 题目描述
给你一个二进制字符串数组 strs 和两个整数 m 和 n 。
请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。
如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

### 思路：二维dp数组🌟

转化：
- 把字符串数组中的字符看作是物品
- m为背包的容量（只能装0）
- n为背包的容量（只能装1）
因此，需要倒序遍历（两个背包）

对于每个字符串（物品）：
1. 不选它：dp[i][j] 保持原值
2. 选它（前提 i >= zeroNums 且 j >= oneNums）：
  - 从“容量减少后的状态”转移过来，并且因为选了这个字符串，数量 +1：

```java
dp[i][j] = max(dp[i][j], dp[i - zeroNums][j - oneNums] + 1)
```

完整代码如下：

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        // dp[i][j] 表示 i个0，j个1的最大子集 长度
        int[][] dp = new int[m + 1][n + 1];

        // 遍历字符串 获取字符串中 0 和 1 的个数
        for(String str : strs){
            int zeroNums = 0;
            int oneNums = 0;
            // 统计当前字符串的 0 和 1 数量
            for(char c : str.toCharArray()){
                if(c == '0') zeroNums++;
                if(c == '1') oneNums++;
            }

            // 使用背包 开始统计————其中 m 和 n 都是背包的容量——都要倒序遍历
            for(int i = m; i >= zeroNums; i--){
                for(int j = n; j >= oneNums; j--){
                    // 不取 或 取 该字符串 —— 不取，不变； 取，则 在剩余容量的技术上 + 1
                    dp[i][j] = Math.max(dp[i][j], dp[i - zeroNums][j - oneNums] + 1);
                }
            }
        }

        return dp[m][n];
    }
}
```

#### 复杂度分析
时间复杂度：O(len * m * n)，len为字符串数组长度

空间复杂度：O(m * n)

### 总结
