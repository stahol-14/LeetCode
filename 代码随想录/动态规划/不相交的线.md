# [不相交的线](不相交的线"[题目地址](https://leetcode.cn/problems/uncrossed-lines/description/)")

## 题目描述
在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。

现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足：
- nums1[i] == nums2[j]
- 且绘制的直线不与任何其他连线（非水平线）相交。

请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。

### 思路：动态规划🌟

难在读懂题意，可以转化为：
- 不相交（相同值的相对位置不变）
- 【最长公共子序列的长度】


```java
class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int len1 = nums1.length;
        int len2 = nums2.length;
        
        // dp[i][j] 表示 nums1 前 i 个数 和 nums2 前 j 个数的最大连线数
        int[][] dp = new int[len1 + 1][len2 + 1];

        for(int i = 1; i <= len1; i++){
            int a = nums1[i - 1];
            for(int j = 1; j <= len2; j++){
                int b = nums2[j - 1];
                if(a == b){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }else{
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[len1][len2];
    }
}
```

#### 复杂度分析
时间复杂度：O(n * m)

空间复杂度：O(n * m)

----

### 优化：一维dp🌟

- 更新 dp[j] 时，要用到上一行 dp[j-1] 的值，因此需要一个临时变量 prev 来保存 左上角 dp[i-1][j-1] 的值。

```java
class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int len1 = nums1.length;
        int len2 = nums2.length;
        
        int[] dp = new int[len2 + 1]; // dp[i][j] 二维降低至一维

        for(int i = 1; i <= len1; i++){
            int prev = 0; // 记录左上角的值 dp[i-1][j-1]

            for(int j = 1; j <= len2; j++){
                int temp = dp[j]; // 暂存当前 dp[j]， 作为下一轮的prev

                if(nums1[i - 1] == nums2[j - 1]){
                    dp[j] = prev + 1;
                }else{
                    dp[j] = Math.max(dp[j], dp[j - 1]); // 不相等，取上方或左方
                }
                prev = temp; // 更新 prev
            }
        }

        return dp[len2];
    }
}
```

#### 复杂度分析
时间复杂度：O(n * m)

空间复杂度：O(n)

### 总结
