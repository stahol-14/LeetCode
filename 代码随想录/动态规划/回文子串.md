# [回文子串](回文子串"[题目地址](https://leetcode.cn/problems/palindromic-substrings/description/)")

## 题目描述
给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。

回文字符串 是正着读和倒过来读一样的字符串。

子字符串 是字符串中的由连续字符组成的一个序列。

### 思路1：双指针扩展

- 以“一个中心”向两边扩展
  - 单个字符（奇数长度回文）—— n个（每个都可以作为中心）
  - 两个相邻字符之间（偶数长度回文）—— n-1个（每两个都可以作为中心）

```java
class Solution {
    public int countSubstrings(String s) {
        int n = s.length();
        int res = 0;

        for(int i = 0; i < n; i++){
            // 以单个字符为中心（奇数长度回文）
            res += subString(s, i, i, n);
            // 以两个相邻字符为中心（偶数长度回文）
            res += subString(s, i, i + 1, n);
        }

        return res;
    }

    private int subString(String s, int left, int right, int length){
        int count = 0;
        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)){
            count++;
            left--;
            right++;
        }

        return count;
    }
}
```

#### 复杂度分析
时间复杂度：O(n ^ 2)

空间复杂度：O(1)

----

### 思路2：动态规划🌟

dp[i][j] 表示i到j的子串，是否为回文子串
- i需要倒序遍历
- j正序遍历(从i开始)
- 即，从二维数组的左下角开始

```java
class Solution {
    public int countSubstrings(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n]; // dp[i][j] 表示 子串i-j是否为回文子串
        int res = 0;

        for(int i = n - 1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(s.charAt(i) == s.charAt(j)){
                    // 字符串相等 需要判断 i和j之间有几个字符
                    // 如果在两个字符以内，即 i (k) j 则为回文子串
                    // 如果大于等于两个字符，则需要 (i+1)-(j-1)为回文子串 —— 因此 i倒序
                    if(j - i < 2 || dp[i + 1][j - 1]){
                        res++;
                        dp[i][j] = true;
                    }
                }
            }
        }

        return res;
    }
}
```

#### 复杂度分析
时间复杂度：O(n ^ 2)

空间复杂度：O(n ^ 2)

### 总结
