# [整数拆分](整数拆分"[题目地址](https://leetcode.cn/problems/integer-break/description/)")

## 题目描述
给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。

返回 你可以获得的最大乘积 。

### 思路1：动态规划 🌟

注：更新比较时，要把当前的dp[i]加入比较

```java
class Solution {
    public int integerBreak(int n) {
        // 动态规划 从小到大 乘上来
        // dp[i] 的计算方式 有：j * (i - j) 或 j * dp[i-j]
        // 分别对应 直接拆分成两部分 和 拆成一部分 另一部分继续拆分

        if(n == 2) return 1; // 剪枝
        if(n == 3) return 2;

        int[] dp = new int[n + 1];
        dp[2] = 1; // 初始化

        for(int i = 3; i <= n; i++){
            for(int j = 1; j < i; j++){
                int curMax = Math.max(j * (i - j), j * dp[i - j]);
                dp[i] = Math.max(dp[i], curMax);
                // 在选择最大值时，用 dp[i] 与 Math.max(j * (i - j), j * dp[i - j]) 进行比较的原因是：
                // dp[i] 可能已经在之前被更新为更优的拆分方式产生的最大值，所以需要保留。
                // 我们在每一步都需要比较直接拆分和递归拆分后的最大值，确保我们在当前情况下得到了最佳解。
            }
        }

        return dp[n];
    }
}
```

#### 复杂度分析
时间复杂度：O(n^2)

空间复杂度：O(n)

----

### 思路2：贪心 + 数学理论

- 固定和：要求最大积，需要让拆分的数字更靠近e，因此3越多越好

```java
class Solution {
    public int integerBreak(int n) {
        // 乘积最大化 —— 拆分数字尽可能相等【本题：固定和——越接近e，越大，因此选择3】
        // 贪心——尽量拆 3
        if(n == 2) return 1;
        if(n == 3) return 2;

        long ans = 1;
        while(n > 4){
            ans *= 3;
            n -= 3;
        }
        // n 此时为 2/3/4，直接乘即可（4=2*2）
        return (int)(ans * n);
    }
}
```

#### 复杂度分析
时间复杂度：O(n)

空间复杂度：O(1)

### 总结
