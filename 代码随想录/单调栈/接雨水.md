# [接雨水](接雨水"[题目地址](https://leetcode.cn/problems/trapping-rain-water/description/)")

## 题目描述
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

### 思路1：单调栈🌟

- 按照**行计算**
- 单调栈中对应的元素是**递增的**（栈顶到栈底）—— 指向的元素，大于栈顶时，形成凹槽，可以接雨水。【存下标】
- 当遇到相同高度的柱子时，需要**更新下标**

注：计算面积的宽度时，是**减1**而不是加1
- 因为不包括边界柱子本身
  - i 是右边界柱子下标
  - left 是左边界柱子下标
  - 中间可以盛水的大小是 i - left - 1 个格子

```java
class Solution {
    public int trap(int[] height) {
        // 单调栈 下标对应的值 递增（栈顶到栈底）
        if(height == null || height.length <= 1){
            return 0;
        }

        int res = 0;
        int n = height.length;
        Deque<Integer> stack = new ArrayDeque<>(); // 单调栈 存放下标

        for(int i = 0; i < n; i++){
            // 判断当前高度 与 栈顶对应高度的关系 大于则形成凹槽
            while( (!stack.isEmpty()) && height[i] > height[stack.peek()] ){
                // 确定柱子的相对低侧
                int bottom = stack.pop(); // 柱子底部
                if(stack.isEmpty()) break; // 没有左边界

                int left = stack.peek();
                int width = i - left - 1;

                int minHeight = Math.min(height[left], height[i]);
                int curRes = (minHeight - height[bottom]) * width;
                res += curRes;
            }
            
            stack.push(i); // 当前下标入栈
        }

        return res;
    }
}
```

#### 复杂度分析
时间复杂度：O(n)

空间复杂度：O(n)

----

### 思路2.1：双指针🌟

- 按列计算

```java
class Solution {
    public int trap(int[] height) {
        // 双指针 —— 按列计算
        if(height == null || height.length <= 1) return 0;

        int res = 0;
        int left = 0, right = height.length - 1;
        int leftMax = height[left], rightMax = height[right]; // 当前列左右侧的高度

        while(left < right){
            if(height[left] < height[right]){
                // 左边比右边矮，决定高度上限的是左边
                left++;
                leftMax = Math.max(leftMax, height[left]);
                res += leftMax - height[left]; // 接水 = 左边最高 - 当前高度（>=0）
            }else{
                // 右边比左边矮，决定高度上限的是右边
                right--;
                rightMax = Math.max(rightMax, height[right]);
                res += rightMax - height[right];
            }
        }

        return res;
    }
}
```

#### 复杂度分析
时间复杂度：O(n)

空间复杂度：O(1)

----

### 思路2.2：双指针🌟（面积相减）

- 接雨水后的面积 - 柱子的面积
- 一层一层的计算（按行计算）

1. 将整个柱子视为由一层层水面组成的；
2. 每一层水面 h，从左到右看，找到左右边界都 ≥ h 的位置；
3. 中间（right - left + 1）范围内的方块都属于这层水的面积；
4. 总水层面积累加到 sumArea 中；
5. 柱子面积为 area，最终结果就是 sumArea - area。

```java
class Solution {
    public int trap(int[] height) {
        if(height == null || height.length <= 1){
            return 0;
        }

        // 双指针 面积相减
        int area = 0; // 柱子的高度
        for(int temp : height){
            area += temp;
        }
        
        int sumArea = 0; // 接完雨水后的总高度
        int left = 0, right = height.length - 1;
        int h = 1; // 从第1层高度开始灌水

        while(left <= right){
            // 当前层的左右边界必须都 ≥ 当前层高度 h，才能接水
            if(height[left] < h){
                left++;
                continue;
            }
            if(height[right] < h){
                right--;
                continue;
            }

            // 如果左右边界都 ≥ h，这一层可以灌水
            sumArea += right - left + 1;
            h++;
        }

        // 用总水层面积 - 柱子面积 = 水的体积
        return sumArea - area;
    }
}
```

#### 复杂度分析
时间复杂度：O(n)

空间复杂度：O(1)

### 总结
