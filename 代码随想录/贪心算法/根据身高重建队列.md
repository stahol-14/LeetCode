# [根据身高重建队列](根据身高重建队列"[题目地址](https://leetcode.cn/problems/queue-reconstruction-by-height/description/)")

## 题目描述
假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

### 思路：贪心 + 插入 🌟

- 重建这个队列，使得每个人的 ki 条件都满足：
  - 这个人前面有 ki 个身高 ≥ hi （这个人的身高）的人
- 身高高的人影响力大（因为可以被别人“看到”）

1. 将 people 按如下方式排序：
    - 身高 h 从高到低
    - 如果身高相同，则 k 从 小到大
2. 然后按顺序遍历排序后的数组，把每个人插入到 res[k] 的位置上
   - 高个子先站好位，矮个子后站，不会影响前面人的 ki 条件
   - 插入到第 k 位，确保前面有 k 个比自己高或一样高的人

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        // 先根据h排序，高的先入队 矮的根据比自己高的人数找自己的位置
        Arrays.sort(people, (a, b) -> {
            if(a[0] == b[0]){
                // 一样高，按照k的大小 升序排列
                return a[1] - b[1];
            }else{
                // 不一样高，则高的在前面
                return b[0] - a[0];
            }
        });

        // 按 k 值插入到目标位置
        // List<int[]> queue = new ArrayList<>();
        List<int[]> queue = new LinkedList<>(); // 频繁插入
        for(int[] person : people){
            queue.add(person[1], person); // 插入到下标 k 位置
        }

        return queue.toArray(new int[people.length][2]); // 转为二维数组返回
    }
}
```

#### 复杂度分析
时间复杂度：O(nlog n + n^2)——排序+插入
空间复杂度：O(n)

### 总结
升序	a - b
降序	b - a