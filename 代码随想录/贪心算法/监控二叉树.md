# [监控二叉树](监控二叉树"[题目地址](https://leetcode.cn/problems/binary-tree-cameras/description/)")

## 题目描述
给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。

计算监控树的所有节点所需的最小摄像头数量。

### 思路：贪心 + 后序遍历🌟
- 因为要摄像头数量尽可能少，所以尽量让摄像头在**叶子结点的父结点**，一直往上到根节点
- 因此，需要最后访问根结点，选择——后序遍历（左右中）

需要记录每个结点的状态：
- 结点值为0：没有被监控覆盖（父结点/叶子结点没有安装摄像头）
- 结点值为1：被监控覆盖
- 结点值为2：当前节点安装了监控

```java
class Solution {

    int result = 0;

    public int minCameraCover(TreeNode root) {
        // 如果根节点没有被监控 摄像头要+1
        if(dfs(root) == 0){
            result++;
        }
        return result;
    }

    private int dfs(TreeNode node){
        // 后序遍历：左 右 中  ———— 需要从底向上

        if(node == null){
            return 1; // 空节点 结束的条件，视为被监控了
        }

        int left = dfs(node.left);
        int right = dfs(node.right);

        // 通过左右孩子的值 判断当前节点是否需要安装摄像头
        // 1. 至少存在一个孩子 没有被监控到 就需要安装
        if(left == 0 || right == 0){
            result++;
            return 2; // 在当前节点安装
        }
        // 2. 两个孩子中有摄像头 当前已被覆盖
        if(left == 2 || right == 2){
            return 1;
        }
        // 3. 两个孩子都被监控到了 证明当前节点没有被覆盖
        return 0;
    }
}
```

#### 复杂度分析
时间复杂度：O(n)，每个节点访问一次

空间复杂度：O(h)，递归栈深度（最坏为 O(n)）

### 总结
