# [重排链表](重排链表"[题目地址](https://leetcode.cn/problems/reorder-list/description/)")

## 题目描述
给定一个单链表 L 的头节点 head ，单链表 L 表示为：

L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

### 思路1：直观——辅助数组


```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public void reorderList(ListNode head) {
        if(head == null || head.next == null) return ;

        // 数组接收
        List<ListNode> list = new ArrayList<>();
        ListNode curr = head;

        while(curr != null){
            list.add(curr);
            curr = curr.next;
        }

        // 对数组进行双指针 重组链表
        int left = 0, right = list.size() - 1;
        while(left < right){
            list.get(left).next = list.get(right);
            left++;

            if(left == right){
                break;
            }

            list.get(right).next = list.get(left);
            right--;
        }

        list.get(left).next = null; // 防止形成环或多余尾巴
    }
}
```

#### 复杂度分析
时间复杂度：O(n)

空间复杂度：O(n)（使用数组存放所有节点）

----

### 思路2：优化——反转链表+双指针合并

1. 快慢指针找中点
2. 分割，反转链表（后半部分）
3. 合并重组

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public void reorderList(ListNode head) {
        // 快慢指针+反转链表+合并重组
        if(head == null || head.next == null) return ;

        // 找中点
        ListNode slow = head, fast = head;
        while(fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }

        // 反转并断开
        ListNode secondNode = reverse(slow.next);
        slow.next = null;

        // 合并
        ListNode firstNode = head;

        while(secondNode != null){
            ListNode temp1 = firstNode.next;
            ListNode temp2 = secondNode.next;

            firstNode.next = secondNode;
            secondNode.next = temp1;

            firstNode = temp1;
            secondNode = temp2;
        }

    }

    // 反转链表
    private ListNode reverse(ListNode head){
        ListNode curr = head, prev = null;
        while(curr != null){
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
}
```

#### 复杂度分析
时间复杂度：O(n)

空间复杂度：O(1)

### 总结
